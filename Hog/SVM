import cv2
import numpy as np
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import os
import time

def Resize(img):
    if img.shape[0] != 128 or img.shape[1] != 64:
        img = cv2.resize(img, (64, 128))
    return img

def featureExtraction(img):
    # To handle division by zero errors. This is a very small number, so it will not affect the result much
    epsilon = 1e-7

    img = Resize(img)

    hog = cv2.HOGDescriptor()
    hog_features = hog.compute(img)

    img = np.float32(img) / 255.0
    
    # Calculate gradient
    gx = cv2.Sobel(img, cv2.CV_32F, 1, 0, ksize=1)
    gy = cv2.Sobel(img, cv2.CV_32F, 0, 1, ksize=1)

    mag, angle = cv2.cartToPolar(gx, gy, angleInDegrees=True)

    histogram = np.zeros((img.shape[0]//8, img.shape[1]//8, 9))
    normalized_histogram = np.zeros((img.shape[0]//8 - 1, img.shape[1]//8 - 1, 36))

    # Calculate Histogram of Gradients in 8Ã—8 cells. Go trough each cell and calculate the histogram
    for i in range(img.shape[0]//8):
        for j in range(img.shape[1]//8):
            # Make a cutout of the cell
            cell_mag = mag[i*8:(i+1)*8, j*8:(j+1)*8]
            cell_angle = angle[i*8:(i+1)*8, j*8:(j+1)*8]

            # Convert all angle values above 180 to the same values below 180
            for k in range(8):
                for l in range(8):
                    while cell_angle[k, l, 0] >= 180:
                        cell_angle[k, l, 0] -= 180

            # Calculate the histogram based on the magnitude and angle of the gradients
            hist = np.zeros(9)
            for k in range(8):
                for l in range(8):

                    # Check what the angles is. If it is between 160 and 180, the value should porportionally be added to the 0 bin and the 160 bin
                    if cell_angle[k, l, 0] >= 160:
                        hist[0] += cell_mag[k, l, 0] * (180 - cell_angle[k, l, 0]) / 20
                        hist[8] += cell_mag[k, l, 0] * (cell_angle[k, l, 0] - 160) / 20
                        continue
                    else:
                        bin = int(cell_angle[k, l, 0] / 20)
                        hist[bin] += cell_mag[k, l, 0]     

            # Save the values in an array                

            histogram[i, j] = hist

    # The histogram is 16 by 8, we now normalize it in 16 by 16 pixels, which is cooresponding to 2 by 2 cells in this matrix.
    # We will roll this normalization over the entire image over the matrices of 2 by 2 cells by shifting it 1 cell the the side each time.
    for i in range(img.shape[0]//8 - 1):
        for j in range(img.shape[1]//8 - 1):
            # Normalize the histogram by making a 36 by 1 vector and normalizing it
            histogram_vector = np.zeros(36)
            histogram_vector[0:9] = histogram[i, j]
            histogram_vector[9:18] = histogram[i, j+1]
            histogram_vector[18:27] = histogram[i+1, j]
            histogram_vector[27:36] = histogram[i+1, j+1]
            histogram_vector = histogram_vector / (np.linalg.norm(histogram_vector) + epsilon)

            # Roll the normalized histogram back into the normalized histogram matrix
            normalized_histogram[i, j] = histogram_vector

    # Create the feature vector
    feature_vector = np.zeros(3780)
    for i in range(img.shape[0]//8 - 1):
        for j in range(img.shape[1]//8-1):
            for k in range(9):
                feature_vector[i*63 + j*9 + k] = normalized_histogram[i, j, k]

    return feature_vector 

def HogFeatureFolderExtractor(BlueConesFolder, YellowConesFolder, NegativeSamplesFolder):
    # Process blue cones, yellow cones, and negative samples folders
    positive_features = []  # To store blue and yellow cone features
    negative_features = []  # To store negative samples features

    Correcly_loaded = 0
    Total_load_attempts = 0

    # Load features from BlueConesFolder and YellowConesFolder
    for idx, folder_path in enumerate([BlueConesFolder, YellowConesFolder]):
        filenames = os.listdir(folder_path)
        for idy, filename in enumerate(filenames):
            feature_vector = np.load(os.path.join(folder_path, filename))
            # Check if we are looking at the first file in the folder
            if not (np.isnan(feature_vector).any()) and (feature_vector.shape[0] == 3780):
                if idx == 0 and idy == 0:
                    positive_features = feature_vector
                else:
                    Correcly_loaded += 1
                    positive_features = np.column_stack((positive_features, feature_vector))
            Total_load_attempts += 1

    # Check how many features are loaded correctly out of the total number of features
    print("Number of features loaded correctly: " + str(Correcly_loaded) + " out of " + str(Total_load_attempts) + " features" )
    print(positive_features.shape)

    Correcly_loaded = 0
    Total_load_attempts = 0

    for idx, folder_path in enumerate([NegativeSamplesFolder]):
        filenames = os.listdir(folder_path)
    for idy, filename in enumerate(filenames):
        feature_vector = np.load(os.path.join(folder_path, filename))
        # Check if we are looking at the first file in the folder
        if not (np.isnan(feature_vector).any()) and (feature_vector.shape[0] == 3780):
            if idx == 0 and idy == 0:
                negative_features = feature_vector
            else:
                Correcly_loaded += 1
                negative_features = np.column_stack((negative_features, feature_vector))
        Total_load_attempts += 1

    # Check how many features are loaded correctly out of the total number of features
    print("Number of features loaded correctly: " + str(Correcly_loaded) + " out of " + str(Total_load_attempts) + " features" )
    print(positive_features.shape)

    # Transpose the feature vectors
    positive_features = positive_features.T
    negative_features = negative_features.T

    # Combine features and create labels for positive and negative samples
    positive_labels = np.ones(len(positive_features))
    negative_labels = np.zeros(len(negative_features))

    return positive_features, positive_labels, negative_features, negative_labels

def trainSVMModel(BlueConesFolder, YellowConesFolder, NegativeSamplesFolder):
    positive_features, positive_labels, negative_features, negative_labels, = HogFeatureFolderExtractor(BlueConesFolder, YellowConesFolder, NegativeSamplesFolder)

    # Combine all features and labels
    X = np.vstack((positive_features, negative_features))
    y = np.concatenate((positive_labels, negative_labels))

    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Train an SVM classifier
    clf = svm.SVC(kernel='linear', C=5)
    clf.fit(X_train, y_train)
    
    return clf

def SVM_predict():
    clf = trainSVMModel("Hog/HogFeatures/Blue", "Hog/HogFeatures/Yellow", "Hog/HogFeatures/NegativeSamples")
    print("Model was trained")

    print(clf)

    # Load the larger image
    larger_image = cv2.imread("Hog/Cones/_PicturesWithCones/frame_0.jpg")

    # Define the size of the sliding window and step size
    window_size = (64, 128)
    step_size = 64

    # Iterate through the image using a sliding window
    for y in range(0, larger_image.shape[0] - window_size[1], step_size):
        for x in range(0, larger_image.shape[1] - window_size[0], step_size):
            # Extract the current window
            window = larger_image[y:y+window_size[1], x:x+window_size[0]]

            # Compute HOG features for the current window (you need to implement this)
            window_features = featureExtraction(window)

            # Use the trained SVM to classify the window
            prediction = clf.predict([window_features])


            # If the window is classified as a cone (1), mark it
            if prediction == 1:
                cv2.rectangle(larger_image, (x, y), (x+window_size[0], y+window_size[1]), (0, 255, 0), 2)

    print("imhere")
    # Display or save the image with potential cone locations marked
    cv2.imshow("Potential Cones", larger_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

SVM_predict()

